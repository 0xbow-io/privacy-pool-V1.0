// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "forge-std/StdJson.sol";

import "../src/verifier/groth16_verifier.sol";
import "../src/interfaces/IPrivacyPool.sol";

contract TestGroth16Verifier is Test {
    Groth16Verifier internal verifier;

    function setUp() public {
        verifier = new Groth16Verifier();
    }

    /**
     * @dev Verify the proof.=
     * run: forge test --match-test test_verifyProof_Static
     */
    function test_verifyProof_Static() public {
        bool result = verifier.verifyProof(
            [
                7379996574277467845188208761708504348698023206079534926150216172458892724734,
                15075508750648124627436275914837887645965759116163198735933696012008793007579
            ],
            [
                [
                    3939547767121413466950806269075743835444852779542629128477029679689598117971,
                    14061142805598056754634663134727309975073433150980227418169884761037026932143
                ],
                [
                    12121183232422189129057814226363686117017287437964015197911966828423735184089,
                    18646024639376910408743801302720282022728578539712941063277078744713687246854
                ]
            ],
            [
                20616671087081733041506343583059934189092147763777501092057429116721387706002,
                6735651654419256766956386230660543202696592412658922207501257674592185840039
            ],
            [
                15695192474633893952661441618086670209534894809826649773643557740559868337064,
                18884030154211907029969977302714020795245100474845175940906019759482116357367,
                0,
                0,
                0,
                0,
                14415182740995834473888636433609243370512214743132120011133634985791276714747,
                17639807239276035889391361574543056337521346503416852381101495567066961425114,
                0,
                0,
                1675909690794578891864902673285720379097961768312703169083948244151439570889,
                12149047637673285725503204890703491417081732217523166659387853590846719171445,
                17860360484857216088464258890461544313806446338584014491183282033613384044019,
                0,
                21516024283721101332796631518290402974360471774654887373746160370306470179536,
                1000000000000000,
                0,
                0,
                10358320209949747949251890588921118777160080409239693828619608802824369315520,
                4244704660024208167202380797934511967372530994462179800859057038705917627974,
                21156213812342457486590387965573426455973940602953185511574398514095442984098,
                11252000568090008451963784491333114233678576737497427682532326376110152700911,
                18700511060914086692294138210612991983411806857661560970267112171145555062530,
                11214980585252815111430678280372659301594804106609023102767138452681062703151,
                10385358882317829582501002253633237721761123882509621812670460186930814442305,
                8775455366663899555205578798510912940435350107347246495576279066040061997016,
                2127108494246854135342529916479634645185417829045614946066958843193825401166,
                3048925217021576098185466039629576051439440301854026902536474714138565053,
                2801609294524554092818739135758344254375592453069617265134572566006020291866,
                19841737047489921111716003717463790998524157228146617674913726739328125621905,
                12515660102973576058972368448200989011643660302792614322416407043151751812073,
                19762645557854875984848939979018162215925700794922501262536489268948900930279,
                512528713755973444289174850904750893167176028612561022913354856185377229382,
                16225269068937061358739433034209673020413561706246420768574444770499377538838,
                20532764065771209153336015821566465085789974336078344261971202608705689815005,
                11162074916061586740621749303906494704696734426227466893451930401922575844467
            ]
        );
        assertTrue(result, "failed to verify proof");
    }

    /**
     * @dev Verify the proof generated by the script/generate_single_proof script.
     * Uses FFI to run the script and read the output.
     * run: forge test --ffi --match-test test_verifyProof_FFI
     */
    function test_verifyProof_FFI() public {
        // Run ffi and read back the generated proof
        string[] memory runJsInputs = new string[](8);
        runJsInputs[0] = "ts-node";
        runJsInputs[1] = "./script/generate_single_proof.js";
        runJsInputs[2] = "123"; // Scope
        runJsInputs[3] = "456"; // context
        runJsInputs[4] = "10000"; // IO[0]
        runJsInputs[5] = "789"; // IO[1]
        runJsInputs[6] = "13"; // actualTreeDepth
        runJsInputs[7] = "101112"; // existingStateRoot

        bytes memory jsResult = vm.ffi(runJsInputs);
        IPrivacyPool.GROTH16Proof memory _proof = abi.decode(
            jsResult,
            (IPrivacyPool.GROTH16Proof)
        );
        bool result = verifier.verifyProof(
            _proof._pA,
            _proof._pB,
            _proof._pC,
            _proof._pubSignals
        );
        assertTrue(result, "failed to verify proof");
    }

    /**
     * @dev Test the compiled Groth16 Verifier
     * against test-data that were generated via
     * the script: zero-knowledge/scripts/privacy-pool/genTestVerifierData.ts
     * run: forge test --match-test test_verifyProof -v
     *
     * Note: disabling this test, using FFI instead to compute proof on the fly.
     * function test_verifyProof() public {
     *     string memory root = vm.projectRoot();
     *     string memory testDataDir = string.concat(root, "/test/test-data/");
     *
     *     for (uint256 i = 0; i < 4; i++) {
     *         for (uint256 j = 0; j < 6; j++) {
     *             string memory filename = string.concat("testcase_", vm.toString(i), "_", vm.toString(j), ".json");
     *             string memory fullPath = string.concat(testDataDir, filename);
     *
     *             // Check if the file exists before processing
     *             string memory json = vm.readFile(fullPath);
     *
     *             uint256[2] memory pA;
     *             pA[0] = json.readUint(".proof[0][0]");
     *             pA[1] = json.readUint(".proof[0][1]");
     *
     *             uint256[2][2] memory pB;
     *             pB[0][0] = json.readUint(".proof[1][0][0]");
     *             pB[0][1] = json.readUint(".proof[1][0][1]");
     *             pB[1][0] = json.readUint(".proof[1][1][0]");
     *             pB[1][1] = json.readUint(".proof[1][1][1]");
     *
     *             uint256[2] memory pC;
     *             pC[0] = json.readUint(".proof[2][0]");
     *             pC[1] = json.readUint(".proof[2][1]");
     *
     *             uint256[36] memory pubSignals;
     *             for (uint256 l = 0; l < 36; l++) {
     *                 pubSignals[l] = json.readUint(string.concat(".proof[3][", vm.toString(l), "]"));
     *             }
     *
     *             bool result = verifier.verifyProof(pA, pB, pC, pubSignals);
     *             assertTrue(result, "proof verificaton failed");
     *         }
     *     }
     * }
     */
}
